<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/oops/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/oops/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/oops/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/oops/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/oops/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/oops/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/oops/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="作者：**yeyan1996链接：https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5dff8a26e51d4558105420ed**   前言这段时间面试官都挺忙的，频频出现在博客文章标题，虽然我不是特别想蹭热度，但是实在想不到好的标题了-。-，蹭蹭就蹭蹭 :) 事实上我在面试的时候确实被问到了这个问题，而且是一道在线 coding 的编程题，当时虽然思路正确，可惜最终也并不算完全答对。 结束后">
<meta property="og:type" content="article">
<meta property="og:title" content="字节跳动面试官：请你实现一个大文件上传和断点续传">
<meta property="og:url" content="https://smartlink-tech.gitee.cn/oops/2020/04/30/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B7%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="作者：**yeyan1996链接：https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5dff8a26e51d4558105420ed**   前言这段时间面试官都挺忙的，频频出现在博客文章标题，虽然我不是特别想蹭热度，但是实在想不到好的标题了-。-，蹭蹭就蹭蹭 :) 事实上我在面试的时候确实被问到了这个问题，而且是一道在线 coding 的编程题，当时虽然思路正确，可惜最终也并不算完全答对。 结束后">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/AE2B4448E01770D923B2F506C0F669C7.png">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/8EF34E5EF06A946C28FDB37904478129.jpg">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/FC81F586B39E70F8D117900391B11542.jpg">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/3A1BC1B0E451802B1DDDFC61D39BA82D.png">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/86C864AA25CBE85B7691FA070F4823A4.png">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/20A8CD23B75BA63D45F9669CFCCCC337.png">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/69ACA3823B2CB59FDCB0DC0442EDBA2F.jpg">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/DE37937C58184496513E9F616E9990CF.jpg">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/22AFBF43E816720D63E890AAAD05702C.png">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/182ABAF1F8679C0A9036E0961759ABD3.png">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/F0B0CFE77677FA589A12DD4019816BBA.jpg">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/43C78C4882C1D7945AA431C10A98EB2D.png">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/29AF7B0C1C11F3293FD503B89B28B01C.jpg">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/07B064077E69223CE4D825D503E7E955.jpg">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/5485BD43F608BCB1B9EA805D26C96A5E.jpg">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/CB9B2353F01708D0AE490AD746A90EA0.jpg">
<meta property="og:image" content="https://smartlink-tech.gitee.cn/Oops/resources/85A8E43CC8D823C90FA0F62A16F73974.jpg">
<meta property="article:published_time" content="2020-04-30T03:23:00.000Z">
<meta property="article:modified_time" content="2020-04-30T08:17:04.065Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://smartlink-tech.gitee.cn/Oops/resources/AE2B4448E01770D923B2F506C0F669C7.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/Oops',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"remove","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://smartlink-tech.gitee.cn/oops/2020/04/30/推荐阅读/字节跳动面试官：请你实现一个大文件上传和断点续传/"/>





  <title>字节跳动面试官：请你实现一个大文件上传和断点续传 | Hexo</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/oops/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/oops/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/oops/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/oops/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/oops/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://smartlink-tech.gitee.cn/oops/oops/2020/04/30/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B7%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="架构组">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/oops/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">字节跳动面试官：请你实现一个大文件上传和断点续传</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-30T11:23:00+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/oops/categories/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">推荐阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p><strong>作者：**</strong>yeyan1996<strong><strong>链接：</strong></strong><a href="https://juejin.im/post/5dff8a26e51d4558105420ed" target="_blank" rel="noopener">https://juejin.im/post/5dff8a26e51d4558105420ed</a>**</p>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这段时间面试官都挺忙的，频频出现在博客文章标题，虽然我不是特别想蹭热度，但是实在想不到好的标题了-。-，蹭蹭就蹭蹭 :)</p>
<p>事实上我在面试的时候确实被问到了这个问题，而且是一道在线 coding 的编程题，当时虽然思路正确，可惜最终也并不算完全答对。</p>
<p>结束后花了一段时间整理了下思路，那么究竟该如何实现一个大文件上传，以及在上传中如何实现断点续传的功能呢？</p>
<p>本文将从零搭建前端和服务端，实现一个大文件上传和断点续传的 demo：</p>
<ul>
<li>前端：<code>vue</code> <code>element-ui</code></li>
<li>服务端：<code>nodejs</code></li>
</ul>
<p>文章有误解的地方，欢迎指出，将在第一时间改正，有更好的实现方式希望留下你的评论。</p>
<h2 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端大文件上传网上的大部分文章已经给出了解决方案，核心是利用 <code>Blob.prototype.slice</code>方法，此方法和数组的 <code>slice</code> 方法相似，调用的 <code>slice</code> 方法可以返回<strong>原文件的某个切片</strong>。</p>
<p>这样我们就可以根据预先设置好的切片最大数量将文件切分为一个个切片，然后借助 http 的可并发性，同时上传多个切片，这样从原本传一个大文件，变成了<strong>同时</strong>传多个小的文件切片，可以大大减少上传时间。</p>
<p>另外由于是并发，传输到服务端的顺序可能会发生变化，所以我们还需要给每个切片记录顺序。</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端需要负责接受这些切片，并在接收到所有切片后<strong>合并</strong>切片。</p>
<p>这里又引伸出两个问题：</p>
<ol>
<li>何时合并切片，即切片什么时候传输完成？</li>
<li>如何合并切片？</li>
</ol>
<p>第一个问题需要前端进行配合，前端在每个切片中都携带切片最大数量的信息，当服务端接收到这个数量的切片时自动合并，也可以额外发一个请求主动通知服务端进行切片的合并。</p>
<p>第二个问题，具体如何合并切片呢？这里可以使用 NodeJS 的 API <code>fs.appendFileSync</code>，它可以同步地将数据追加到指定文件，也就是说，当服务端接收完所有切片后，可以先创建一个空文件，然后将所有切片逐步合并到这个文件中。</p>
<p><strong>so，talk is cheap, show me the code</strong>，接着让我们用代码实现上面的思路吧。</p>
<h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><p>前端使用 <strong>Vue</strong> 作为开发框架，对界面没有太大要求，原生也可以，考虑到美观使用 <strong>Element-UI</strong> 作为 <strong>UI</strong> 框架。</p>
<h3 id="上传控件"><a href="#上传控件" class="headerlink" title="上传控件"></a>上传控件</h3><p>首先创建选择文件的控件，监听 <code>change</code> 事件以及上传按钮：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   \&lt;div\&gt;</span><br><span class="line"> \&lt;input type&#x3D;&quot;file&quot; @change&#x3D;&quot;handleFileChange&quot; &#x2F;\&gt;</span><br><span class="line"> \&lt;el-button @click&#x3D;&quot;handleUpload&quot;\&gt;上传\&lt;&#x2F;el-button\&gt;</span><br><span class="line"> \&lt;&#x2F;div\&gt;</span><br><span class="line">\&lt;&#x2F;template\&gt;</span><br><span class="line"></span><br><span class="line">\&lt;script\&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"> data: () &#x3D;\&gt; (&#123;</span><br><span class="line"> container: &#123;</span><br><span class="line"> file: null</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;),</span><br><span class="line"> methods: &#123;</span><br><span class="line"> handleFileChange(e) &#123;</span><br><span class="line"> const [file] &#x3D; e.target.files;</span><br><span class="line"> if (!file) return;</span><br><span class="line"> Object.assign(this.$data, this.$options.data());</span><br><span class="line"> this.container.file &#x3D; file;</span><br><span class="line"> &#125;,</span><br><span class="line"> async handleUpload() &#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">\&lt;&#x2F;script\&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/Oops/resources/AE2B4448E01770D923B2F506C0F669C7.png" alt></p>
<h3 id="请求逻辑"><a href="#请求逻辑" class="headerlink" title="请求逻辑"></a>请求逻辑</h3><p>考虑到通用性，这里没有用第三方的请求库，而是用原生 <code>XMLHttpRequest</code> 做一层简单的封装来发请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">request(&#123;</span><br><span class="line">    url,</span><br><span class="line">    method &#x3D; &quot;post&quot;,</span><br><span class="line">    data,</span><br><span class="line">    headers &#x3D; &#123;&#125;,</span><br><span class="line">    requestList</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    return new Promise(resolve &#x3D;\&gt; &#123;</span><br><span class="line">        const xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">        Object.keys(headers).forEach(key &#x3D;\&gt;</span><br><span class="line">            xhr.setRequestHeader(key, headers[key])</span><br><span class="line">        );</span><br><span class="line">        xhr.send(data);</span><br><span class="line">        xhr.onload &#x3D; e &#x3D;\&gt; &#123;</span><br><span class="line">            resolve(&#123;</span><br><span class="line">                data: e.target.response</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="上传切片"><a href="#上传切片" class="headerlink" title="上传切片"></a>上传切片</h3><p>接着实现比较重要的上传功能，上传需要做两件事：</p>
<ol>
<li>对文件进行切片</li>
<li>将切片传输给服务端</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; @change&#x3D;&quot;handleFileChange&quot; &#x2F;&gt;</span><br><span class="line">    &lt;el-button @click&#x3D;&quot;handleUpload&quot;&gt;上传&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">+ const LENGTH &#x3D; 10; &#x2F;&#x2F; 切片数量</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data: () &#x3D;&gt; (&#123;</span><br><span class="line">    container: &#123;</span><br><span class="line">      file: null,</span><br><span class="line">+ data: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  methods: &#123;</span><br><span class="line">    request() &#123;&#125;,</span><br><span class="line">    handleFileChange() &#123;&#125;,</span><br><span class="line">+ &#x2F;&#x2F; 生成文件切片</span><br><span class="line">+ createFileChunk(file, length &#x3D; LENGTH) &#123;</span><br><span class="line">+ const fileChunkList &#x3D; [];</span><br><span class="line">+ const chunkSize &#x3D; Math.ceil(file.size &#x2F; length);</span><br><span class="line">+ let cur &#x3D; 0;</span><br><span class="line">+ while (cur \&lt; file.size) &#123;</span><br><span class="line">+ fileChunkList.push(&#123; file: file.slice(cur, cur + chunkSize) &#125;);</span><br><span class="line">+ cur +&#x3D; chunkSize;</span><br><span class="line">+ &#125;</span><br><span class="line">+ return fileChunkList;</span><br><span class="line">+ &#125;,</span><br><span class="line">+ &#x2F;&#x2F; 上传切片</span><br><span class="line">+ async uploadChunks() &#123;</span><br><span class="line">+ const requestList &#x3D; this.data</span><br><span class="line">+ .map((&#123; chunk &#125;) &#x3D;\&gt; &#123;</span><br><span class="line">+ const formData &#x3D; new FormData();</span><br><span class="line">+ formData.append(&quot;chunk&quot;, chunk);</span><br><span class="line">+ formData.append(&quot;hash&quot;, hash);</span><br><span class="line">+ formData.append(&quot;filename&quot;, this.container.file.name);</span><br><span class="line">+ return &#123; formData &#125;;</span><br><span class="line">+ &#125;)</span><br><span class="line">+ .map(async (&#123; formData &#125;) &#x3D;\&gt;</span><br><span class="line">+ this.request(&#123;</span><br><span class="line">+ url: &quot;http:&#x2F;&#x2F;localhost:3000&quot;,</span><br><span class="line">+ data: formData</span><br><span class="line">+ &#125;)</span><br><span class="line">+ );</span><br><span class="line">+ await Promise.all(requestList); &#x2F;&#x2F; 并发切片</span><br><span class="line">+ &#125;,</span><br><span class="line">+ async handleUpload() &#123;</span><br><span class="line">+ if (!this.container.file) return;</span><br><span class="line">+ const fileChunkList &#x3D; this.createFileChunk(this.container.file);</span><br><span class="line">+ this.data &#x3D; fileChunkList.map((&#123; file &#125;，index) &#x3D;\&gt; (&#123;</span><br><span class="line">+ chunk: file,</span><br><span class="line">+ hash: this.container.file.name + &quot;-&quot; + index &#x2F;&#x2F; 文件名 + 数组下标</span><br><span class="line">+ &#125;));</span><br><span class="line">+ await this.uploadChunks();</span><br><span class="line">+ &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>当点击上传按钮时，调用 <code>createFileChunk</code> 将文件切片，切片数量通过一个常量 <code>Length</code> 控制，这里设置为 10，即将文件分成 10 个切片上传。</p>
<p><code>createFileChunk</code> 内使用 <code>while</code> 循环和 <code>slice</code> 方法将切片放入 <code>fileChunkList</code> 数组中返回。</p>
<p>在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用<strong>文件名 + 下标</strong>，这样后端可以知道当前切片是第几个切片，用于之后的合并切片。</p>
<p>随后调用 <code>uploadChunks</code> 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 <code>FormData</code> 中，再调用上一步的 <code>request</code> 函数返回一个 <code>proimise</code>，最后调用 <code>Promise.all</code> 并发上传所有的切片。</p>
<h3 id="发送合并请求"><a href="#发送合并请求" class="headerlink" title="发送合并请求"></a>发送合并请求</h3><p>这里使用整体思路中提到的第二种合并切片的方式，即前端主动通知服务端进行合并，所以前端还需要额外发请求，服务端接受到这个请求时主动合并切片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; @change&#x3D;&quot;handleFileChange&quot; &#x2F;&gt;</span><br><span class="line">    &lt;el-button @click&#x3D;&quot;handleUpload&quot;&gt;上传&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data: () &#x3D;&gt; (&#123;</span><br><span class="line">    container: &#123;</span><br><span class="line">      file: null</span><br><span class="line">    &#125;,</span><br><span class="line">    data: []</span><br><span class="line">  &#125;),</span><br><span class="line">  methods: &#123;</span><br><span class="line">    request() &#123;&#125;,</span><br><span class="line">    handleFileChange() &#123;&#125;,</span><br><span class="line">    createFileChunk() &#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F; 上传切片，同时过滤已上传的切片</span><br><span class="line">    async uploadChunks() &#123;</span><br><span class="line">      const requestList &#x3D; this.data</span><br><span class="line">        .map((&#123; chunk &#125;) &#x3D;&gt; &#123;</span><br><span class="line">          const formData &#x3D; new FormData();</span><br><span class="line">          formData.append(&quot;chunk&quot;, chunk);</span><br><span class="line">          formData.append(&quot;hash&quot;, hash);</span><br><span class="line">          formData.append(&quot;filename&quot;, this.container.file.name);</span><br><span class="line">          return &#123; formData &#125;;</span><br><span class="line">        &#125;)</span><br><span class="line">        .map(async (&#123; formData &#125;) &#x3D;&gt;</span><br><span class="line">          this.request(&#123;</span><br><span class="line">            url: &quot;http:&#x2F;&#x2F;localhost:3000&quot;,</span><br><span class="line">            data: formData</span><br><span class="line">          &#125;)</span><br><span class="line">        );</span><br><span class="line">      await Promise.all(requestList);</span><br><span class="line">+ &#x2F;&#x2F; 合并切片</span><br><span class="line">+ await this.mergeRequest();</span><br><span class="line">    &#125;,</span><br><span class="line">+ async mergeRequest() &#123;</span><br><span class="line">+ await this.request(&#123;</span><br><span class="line">+ url: &quot;http:&#x2F;&#x2F;localhost:3000&#x2F;merge&quot;,</span><br><span class="line">+ headers: &#123;</span><br><span class="line">+ &quot;content-type&quot;: &quot;application&#x2F;json&quot;</span><br><span class="line">+ &#125;,</span><br><span class="line">+ data: JSON.stringify(&#123;</span><br><span class="line">+ filename: this.container.file.name</span><br><span class="line">+ &#125;)</span><br><span class="line">+ &#125;);</span><br><span class="line">+ &#125;,</span><br><span class="line">    async handleUpload() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="服务端部分"><a href="#服务端部分" class="headerlink" title="服务端部分"></a>服务端部分</h2><p>简单使用 HTTP 模块搭建服务端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const http &#x3D; require(&quot;http&quot;);</span><br><span class="line">const server &#x3D; http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&quot;request&quot;, async (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;\*&quot;);</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;\*&quot;);</span><br><span class="line">  if (req.method &#x3D;&#x3D;&#x3D; &quot;OPTIONS&quot;) &#123;</span><br><span class="line">    res.status &#x3D; 200;</span><br><span class="line">    res.end();</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(3000, () &#x3D;&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br></pre></td></tr></table></figure>

<h3 id="接受切片"><a href="#接受切片" class="headerlink" title="接受切片"></a>接受切片</h3><p>使用 <code>multiparty</code> 包处理前端传来的 <code>FormData</code>，在 <code>multiparty.parse</code> 的回调中，<code>files</code> 参数保存了 <code>FormData</code> 中文件，<code>fields</code> 参数保存了 <code>FormData</code> 中非文件的字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">const http &#x3D; require(&quot;http&quot;);</span><br><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line">const fse &#x3D; require(&quot;fs-extra&quot;);</span><br><span class="line">const multiparty &#x3D; require(&quot;multiparty&quot;);</span><br><span class="line"></span><br><span class="line">const server &#x3D; http.createServer();</span><br><span class="line">+ const UPLOAD\_DIR &#x3D; path.resolve(\_\_dirname, &quot;..&quot;, &quot;target&quot;); &#x2F;&#x2F; 大文件存储目录</span><br><span class="line"></span><br><span class="line">server.on(&quot;request&quot;, async (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">  if (req.method &#x3D;&#x3D;&#x3D; &quot;OPTIONS&quot;) &#123;</span><br><span class="line">    res.status &#x3D; 200;</span><br><span class="line">    res.end();</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">+ const multipart &#x3D; new multiparty.Form();</span><br><span class="line"></span><br><span class="line">+ multipart.parse(req, async (err, fields, files) &#x3D;\&gt; &#123;</span><br><span class="line">+ if (err) &#123;</span><br><span class="line">+ return;</span><br><span class="line">+ &#125;</span><br><span class="line">+ const [chunk] &#x3D; files.chunk;</span><br><span class="line">+ const [hash] &#x3D; fields.hash;</span><br><span class="line">+ const [filename] &#x3D; fields.filename;</span><br><span class="line">+ const chunkDir &#x3D; &#96;$&#123;UPLOAD\_DIR&#125;&#x2F;$&#123;filename&#125;&#96;;</span><br><span class="line"></span><br><span class="line">+ &#x2F;&#x2F; 切片目录不存在，创建切片目录</span><br><span class="line">+ if (!fse.existsSync(chunkDir)) &#123;</span><br><span class="line">+ await fse.mkdirs(chunkDir);</span><br><span class="line">+ &#125;</span><br><span class="line"></span><br><span class="line">+ &#x2F;&#x2F; fs-extra 专用方法，类似 fs.rename 并且跨平台</span><br><span class="line">+ &#x2F;&#x2F; fs-extra 的 rename 方法 windows 平台会有权限问题</span><br><span class="line">+ &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;meteor&#x2F;meteor&#x2F;issues&#x2F;7852\#issuecomment-255767835</span><br><span class="line">+ await fse.move(chunk.path, &#96;$&#123;chunkDir&#125;&#x2F;$&#123;hash&#125;&#96;);</span><br><span class="line">+ res.end(&quot;received file chunk&quot;);</span><br><span class="line">+ &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(3000, () &#x3D;&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br></pre></td></tr></table></figure>

<p><img src="/Oops/resources/8EF34E5EF06A946C28FDB37904478129.jpg" alt></p>
<p>查看 <code>multiparty</code> 处理后的 chunk 对象，<code>path</code> 是存储临时文件的路径，<code>size</code> 是临时文件大小，在 <code>multiparty</code> 文档中提到可以使用 <code>fs.rename</code>(由于我用的是 <code>fs-extra</code>，其 <code>rename</code> 方法在 Windows 系统上存在权限问题，所以换成了 <code>fse.move</code>) 重命名的方式移动临时文件，也就是文件切片。</p>
<p>在接受文件切片时，需要先创建存储切片的文件夹，由于前端在发送每个切片时额外携带了唯一值 hash，所以以 hash 作为文件名，将切片从临时路径移动切片文件夹中，最后的结果如下</p>
<p><img src="/Oops/resources/FC81F586B39E70F8D117900391B11542.jpg" alt></p>
<h3 id="合并切片"><a href="#合并切片" class="headerlink" title="合并切片"></a>合并切片</h3><p>在接收到前端发送的合并请求后，服务端将文件夹下的所有切片进行合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">const http &#x3D; require(&quot;http&quot;);</span><br><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line">const fse &#x3D; require(&quot;fs-extra&quot;);</span><br><span class="line"></span><br><span class="line">const server &#x3D; http.createServer();</span><br><span class="line">const UPLOAD_DIR &#x3D; path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); &#x2F;&#x2F; 大文件存储目录</span><br><span class="line"></span><br><span class="line">+ const resolvePost &#x3D; req &#x3D;\&gt;</span><br><span class="line">+ new Promise(resolve &#x3D;\&gt; &#123;</span><br><span class="line">+ let chunk &#x3D; &quot;&quot;;</span><br><span class="line">+ req.on(&quot;data&quot;, data &#x3D;\&gt; &#123;</span><br><span class="line">+ chunk +&#x3D; data;</span><br><span class="line">+ &#125;);</span><br><span class="line">+ req.on(&quot;end&quot;, () &#x3D;\&gt; &#123;</span><br><span class="line">+ resolve(JSON.parse(chunk));</span><br><span class="line">+ &#125;);</span><br><span class="line">+ &#125;);</span><br><span class="line"></span><br><span class="line">+ &#x2F;&#x2F; 合并切片</span><br><span class="line">+ const mergeFileChunk &#x3D; async (filePath, filename) &#x3D;\&gt; &#123;</span><br><span class="line">+ const chunkDir &#x3D; &#96;$&#123;UPLOAD\_DIR&#125;&#x2F;$&#123;filename&#125;&#96;;</span><br><span class="line">+ const chunkPaths &#x3D; await fse.readdir(chunkDir);</span><br><span class="line">+ await fse.writeFile(filePath, &quot;&quot;);</span><br><span class="line">+ chunkPaths.forEach(chunkPath &#x3D;\&gt; &#123;</span><br><span class="line">+ fse.appendFileSync(filePath, fse.readFileSync(&#96;$&#123;chunkDir&#125;&#x2F;$&#123;chunkPath&#125;&#96;));</span><br><span class="line">+ fse.unlinkSync(&#96;$&#123;chunkDir&#125;&#x2F;$&#123;chunkPath&#125;&#96;);</span><br><span class="line">+ &#125;);</span><br><span class="line">+ fse.rmdirSync(chunkDir); &#x2F;&#x2F; 合并后删除保存切片的目录</span><br><span class="line">+ &#125;;</span><br><span class="line"></span><br><span class="line">server.on(&quot;request&quot;, async (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">  if (req.method &#x3D;&#x3D;&#x3D; &quot;OPTIONS&quot;) &#123;</span><br><span class="line">    res.status &#x3D; 200;</span><br><span class="line">    res.end();</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">+ if (req.url &#x3D;&#x3D;&#x3D; &quot;&#x2F;merge&quot;) &#123;</span><br><span class="line">+ const data &#x3D; await resolvePost(req);</span><br><span class="line">+ const &#123; filename &#125; &#x3D; data;</span><br><span class="line">+ const filePath &#x3D; &#96;$&#123;UPLOAD\_DIR&#125;&#x2F;$&#123;filename&#125;&#96;;</span><br><span class="line">+ await mergeFileChunk(filePath, filename);</span><br><span class="line">+ res.end(</span><br><span class="line">+ JSON.stringify(&#123;</span><br><span class="line">+ code: 0,</span><br><span class="line">+ message: &quot;file merged success&quot;</span><br><span class="line">+ &#125;)</span><br><span class="line">+ );</span><br><span class="line">+ &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(3000, () &#x3D;&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br></pre></td></tr></table></figure>

<p>由于前端在发送合并请求时会携带文件名，服务端根据文件名可以找到上一步创建的切片文件夹。</p>
<p>接着使用 <code>fs.writeFileSync</code> 先创建一个空文件，这个空文件的文件名就是<strong>切片文件夹名 + 后缀名</strong>组合而成，随后通过 <code>fs.appendFileSync</code> 从切片文件夹中不断将切片合并到空文件中，每次合并完成后删除这个切片，等所有切片都合并完毕后最后删除切片文件夹。</p>
<p><img src="/Oops/resources/3A1BC1B0E451802B1DDDFC61D39BA82D.png" alt></p>
<p>至此一个简单的大文件上传就完成了，接下来我们在此基础上扩展一些额外的功能。</p>
<h2 id="显示上传进度条"><a href="#显示上传进度条" class="headerlink" title="显示上传进度条"></a>显示上传进度条</h2><p>上传进度分两种，一个是每个切片的上传进度，另一个是整个文件的上传进度，而整个文件的上传进度是基于每个切片上传进度计算而来，所以我们需要先实现切片的上传进度。</p>
<h3 id="切片进度条"><a href="#切片进度条" class="headerlink" title="切片进度条"></a>切片进度条</h3><p><code>XMLHttpRequest</code> 原生支持上传进度的监听，只需要监听 <code>upload.onprogress</code> 即可，我们在原来的 <code>request</code> 基础上传入 <code>onProgress</code> 参数，给 <code>XMLHttpRequest</code> 注册监听事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; xhr</span><br><span class="line">    request(&#123;</span><br><span class="line">      url,</span><br><span class="line">      method &#x3D; &quot;post&quot;,</span><br><span class="line">      data,</span><br><span class="line">      headers &#x3D; &#123;&#125;,</span><br><span class="line">+ onProgress &#x3D; e &#x3D;\&gt; e,</span><br><span class="line">      requestList</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">      return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">        const xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">+ xhr.upload.onprogress &#x3D; onProgress;</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">        Object.keys(headers).forEach(key &#x3D;&gt;</span><br><span class="line">          xhr.setRequestHeader(key, headers[key])</span><br><span class="line">        );</span><br><span class="line">        xhr.send(data);</span><br><span class="line">        xhr.onload &#x3D; e &#x3D;&gt; &#123;</span><br><span class="line">          resolve(&#123;</span><br><span class="line">            data: e.target.response</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由于每个切片都需要触发独立的监听事件，所以还需要一个工厂函数，根据传入的切片返回不同的监听函数。</p>
<p>在原先的前端上传逻辑中新增监听函数部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 上传切片，同时过滤已上传的切片</span><br><span class="line">    async uploadChunks(uploadedList &#x3D; []) &#123;</span><br><span class="line">      const requestList &#x3D; this.data</span><br><span class="line">        .map((&#123; chunk &#125;) &#x3D;&gt; &#123;</span><br><span class="line">          const formData &#x3D; new FormData();</span><br><span class="line">          formData.append(&quot;chunk&quot;, chunk);</span><br><span class="line">          formData.append(&quot;filename&quot;, this.container.file.name);</span><br><span class="line">          return &#123; formData &#125;;</span><br><span class="line">        &#125;)</span><br><span class="line">        .map(async (&#123; formData &#125;) &#x3D;&gt;</span><br><span class="line">          this.request(&#123;</span><br><span class="line">            url: &quot;http:&#x2F;&#x2F;localhost:3000&quot;,</span><br><span class="line">            data: formData，</span><br><span class="line">+ onProgress: this.createProgressHandler(this.data[index]),</span><br><span class="line">          &#125;)</span><br><span class="line">        );</span><br><span class="line">      await Promise.all(requestList);</span><br><span class="line">       &#x2F;&#x2F; 合并切片</span><br><span class="line">      await this.mergeRequest();</span><br><span class="line">    &#125;,</span><br><span class="line">    async handleUpload() &#123;</span><br><span class="line">      if (!this.container.file) return;</span><br><span class="line">      const fileChunkList &#x3D; this.createFileChunk(this.container.file);</span><br><span class="line">      this.data &#x3D; fileChunkList.map((&#123; file &#125;，index) &#x3D;&gt; (&#123;</span><br><span class="line">        chunk: file,</span><br><span class="line">+ index,</span><br><span class="line">        hash: this.container.file.name + &quot;-&quot; + index</span><br><span class="line">+ percentage:0</span><br><span class="line">      &#125;));</span><br><span class="line">      await this.uploadChunks();</span><br><span class="line">    &#125;</span><br><span class="line">+ createProgressHandler(item) &#123;</span><br><span class="line">+ return e &#x3D;\&gt; &#123;</span><br><span class="line">+ item.percentage &#x3D; parseInt(String((e.loaded &#x2F; e.total) \* 100));</span><br><span class="line">+ &#125;;</span><br><span class="line">+ &#125;</span><br></pre></td></tr></table></figure>

<p>每个切片在上传时都会通过监听函数更新 <code>data</code> 数组对应元素的 <code>percentage</code> 属性，之后把将 <code>data</code> 数组放到视图中展示即可。</p>
<h3 id="文件进度条"><a href="#文件进度条" class="headerlink" title="文件进度条"></a>文件进度条</h3><p>将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件的上传进度，所以这里使用 Vue 计算属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">     uploadPercentage() &#123;</span><br><span class="line">        if (!this.container.file || !this.data.length) return 0;</span><br><span class="line">        const loaded &#x3D; this.data</span><br><span class="line">          .map(item &#x3D;\&gt; item.size * item.percentage)</span><br><span class="line">          .reduce((acc, cur) &#x3D;\&gt; acc + cur);</span><br><span class="line">        return parseInt((loaded &#x2F; this.container.file.size).toFixed(2));</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终效果如下：</p>
<p><img src="/Oops/resources/86C864AA25CBE85B7691FA070F4823A4.png" alt></p>
<h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><p>断点续传的原理在于前端/服务端需要<strong>记住</strong>已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能：</p>
<ol>
<li>前端使用 <code>localStorage</code> 记录已上传的切片 hash。</li>
<li>服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片。</li>
</ol>
<p>第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选取后者。</p>
<h2 id="生成-hash"><a href="#生成-hash" class="headerlink" title="生成 hash"></a>生成 hash</h2><p>无论是前端还是服务端，都必须要生成文件和切片的 hash，<strong>之前我们使用文件名 + 切片下标作为切片 hash</strong>，这样做文件名一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是<strong>根据文件内容生成 hash</strong>，所以我们需要修改一下 hash 的生成规则。</p>
<p>这里用到另一个库 <code>spark-md5</code>，它可以根据文件内容计算出文件的 hash 值，另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会<strong>引起 UI 的阻塞</strong>，导致页面假死状态，所以我们使用 <strong>web-worker</strong> 在 <strong>worker</strong> 线程计算 hash，这样用户仍可以在主界面正常的交互。</p>
<p>由于实例化 <strong>web-worker</strong> 时，参数是一个 JavaScript 文件路径，且不能跨域。所以我们单独创建一个 <strong>hash.js</strong> 文件放在 <strong>public</strong> 目录下，另外在 <strong>worker</strong> 中也是不允许访问 <strong>DOM</strong> 的，但它提供了<code>importScripts</code> 函数用于导入外部脚本，通过它导入 <code>spark-md5</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &#x2F;public&#x2F;hash.js</span><br><span class="line">self.importScripts(&quot;&#x2F;spark-md5.min.js&quot;); &#x2F;&#x2F; 导入脚本</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生成文件 hash</span><br><span class="line">self.onmessage &#x3D; e &#x3D;\&gt; &#123;</span><br><span class="line">  const &#123; fileChunkList &#125; &#x3D; e.data;</span><br><span class="line">  const spark &#x3D; new self.SparkMD5.ArrayBuffer();</span><br><span class="line">  let percentage &#x3D; 0;</span><br><span class="line">  let count &#x3D; 0;</span><br><span class="line">  const loadNext &#x3D; index &#x3D;\&gt; &#123;</span><br><span class="line">    const reader &#x3D; new FileReader();</span><br><span class="line">    reader.readAsArrayBuffer(fileChunkList[index].file);</span><br><span class="line">    reader.onload &#x3D; e &#x3D;\&gt; &#123;</span><br><span class="line">      count++;</span><br><span class="line">      spark.append(e.target.result);</span><br><span class="line">      if (count &#x3D;&#x3D;&#x3D; fileChunkList.length) &#123;</span><br><span class="line">        self.postMessage(&#123;</span><br><span class="line">          percentage: 100,</span><br><span class="line">          hash: spark.end()</span><br><span class="line">        &#125;);</span><br><span class="line">        self.close();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        percentage +&#x3D; 100 &#x2F; fileChunkList.length;</span><br><span class="line">        self.postMessage(&#123;</span><br><span class="line">          percentage</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; 递归计算下一个切片</span><br><span class="line">        loadNext(count);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  loadNext(0);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <strong>worker</strong> 线程中，接受文件切片 <code>fileChunkList</code>，利用 <code>FileReader</code> 读取每个切片的 <code>ArrayBuffer</code> 并不断传入 <code>spark-md5</code> 中，每计算完一个切片通过 <code>postMessage</code> 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程。</p>
<p><code>spark-md5</code> 需要根据所有切片才能算出一个 hash 值，不能直接将整个文件放入计算，否则即使不同文件也会有相同的 hash，具体可以看官方文档。</p>
<p>spark-md5[1]</p>
<p>接着编写主线程与 <strong>worker</strong> 线程通讯的逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ &#x2F;&#x2F; 生成文件 hash（web-worker）</span><br><span class="line">+ calculateHash(fileChunkList) &#123;</span><br><span class="line">+ return new Promise(resolve &#x3D;\&gt; &#123;</span><br><span class="line">+ &#x2F;&#x2F; 添加 worker 属性</span><br><span class="line">+ this.container.worker &#x3D; new Worker(&quot;&#x2F;hash.js&quot;);</span><br><span class="line">+ this.container.worker.postMessage(&#123; fileChunkList &#125;);</span><br><span class="line">+ this.container.worker.onmessage &#x3D; e &#x3D;\&gt; &#123;</span><br><span class="line">+ const &#123; percentage, hash &#125; &#x3D; e.data;</span><br><span class="line">+ this.hashPercentage &#x3D; percentage;</span><br><span class="line">+ if (hash) &#123;</span><br><span class="line">+ resolve(hash);</span><br><span class="line">+ &#125;</span><br><span class="line">+ &#125;;</span><br><span class="line">+ &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    async handleUpload() &#123;</span><br><span class="line">      if (!this.container.file) return;</span><br><span class="line">      const fileChunkList &#x3D; this.createFileChunk(this.container.file);</span><br><span class="line">+ this.container.hash &#x3D; await this.calculateHash(fileChunkList);</span><br><span class="line">      this.data &#x3D; fileChunkList.map((&#123; file &#125;，index) &#x3D;&gt; (&#123;</span><br><span class="line">+ fileHash: this.container.hash,</span><br><span class="line">        chunk: file,</span><br><span class="line">        hash: this.container.file.name + &quot;-&quot; + index, &#x2F;&#x2F; 文件名 + 数组下标</span><br><span class="line">        percentage:0</span><br><span class="line">      &#125;));</span><br><span class="line">      await this.uploadChunks();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主线程使用 <code>postMessage</code> 给 <strong>worker</strong> 线程传入所有切片 <code>fileChunkList</code>，并监听 <strong>worker</strong> 线程发出的 <code>postMessage</code> 事件拿到文件 hash。</p>
<p>加上显示计算 hash 的进度条，看起来像这样</p>
<p><img src="/Oops/resources/20A8CD23B75BA63D45F9669CFCCCC337.png" alt></p>
<p>至此前端需要将之前用文件名作为 hash 的地方改写为 <strong>workder</strong> 返回的这个 hash。</p>
<p><img src="/Oops/resources/69ACA3823B2CB59FDCB0DC0442EDBA2F.jpg" alt></p>
<p>服务端则使用 hash 作为切片文件夹名，hash + 下标作为切片名，hash + 扩展名作为文件名，没有新增的逻辑。</p>
<p><img src="/Oops/resources/DE37937C58184496513E9F616E9990CF.jpg" alt>)<img src="/Oops/resources/22AFBF43E816720D63E890AAAD05702C.png" alt></p>
<h2 id="文件秒传"><a href="#文件秒传" class="headerlink" title="文件秒传"></a>文件秒传</h2><p>在实现断点续传前先简单介绍一下文件秒传。</p>
<p>所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户<code>再次上传</code>时会直接提示上传成功</p>
<p>文件秒传需要依赖上一步生成的 hash，即在<strong>上传前</strong>，先计算出文件 hash，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+ async verifyUpload(filename, fileHash) &#123;</span><br><span class="line">+ const &#123; data &#125; &#x3D; await this.request(&#123;</span><br><span class="line">+ url: &quot;http:&#x2F;&#x2F;localhost:3000&#x2F;verify&quot;,</span><br><span class="line">+ headers: &#123;</span><br><span class="line">+ &quot;content-type&quot;: &quot;application&#x2F;json&quot;</span><br><span class="line">+ &#125;,</span><br><span class="line">+ data: JSON.stringify(&#123;</span><br><span class="line">+ filename,</span><br><span class="line">+ fileHash</span><br><span class="line">+ &#125;)</span><br><span class="line">+ &#125;);</span><br><span class="line">+ return JSON.parse(data);</span><br><span class="line">+ &#125;,</span><br><span class="line">   async handleUpload() &#123;</span><br><span class="line">      if (!this.container.file) return;</span><br><span class="line">      const fileChunkList &#x3D; this.createFileChunk(this.container.file);</span><br><span class="line">      this.container.hash &#x3D; await this.calculateHash(fileChunkList);</span><br><span class="line">+ const &#123; shouldUpload &#125; &#x3D; await this.verifyUpload(</span><br><span class="line">+ this.container.file.name,</span><br><span class="line">+ this.container.hash</span><br><span class="line">+ );</span><br><span class="line">+ if (!shouldUpload) &#123;</span><br><span class="line">+ this.$message.success(&quot;秒传：上传成功&quot;);</span><br><span class="line">+ return;</span><br><span class="line">+ &#125;</span><br><span class="line">     this.data &#x3D; fileChunkList.map((&#123; file &#125;, index) &#x3D;&gt; (&#123;</span><br><span class="line">        fileHash: this.container.hash,</span><br><span class="line">        index,</span><br><span class="line">        hash: this.container.hash + &quot;-&quot; + index,</span><br><span class="line">        chunk: file,</span><br><span class="line">        percentage: 0</span><br><span class="line">      &#125;));</span><br><span class="line">      await this.uploadChunks();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>秒传其实就是给用户看的障眼法，实质上根本没有上传。就像下面这行代码 :)</p>
<p><img src="/Oops/resources/182ABAF1F8679C0A9036E0961759ABD3.png" alt></p>
<p>服务端的逻辑非常简单，新增一个验证接口，验证文件是否存在即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">+ const extractExt &#x3D; filename &#x3D;\&gt;</span><br><span class="line">+ filename.slice(filename.lastIndexOf(&quot;.&quot;), filename.length); &#x2F;&#x2F; 提取后缀名</span><br><span class="line">const UPLOAD_DIR &#x3D; path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); &#x2F;&#x2F; 大文件存储目录</span><br><span class="line"></span><br><span class="line">const resolvePost &#x3D; req &#x3D;&gt;</span><br><span class="line">  new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    let chunk &#x3D; &quot;&quot;;</span><br><span class="line">    req.on(&quot;data&quot;, data &#x3D;&gt; &#123;</span><br><span class="line">      chunk +&#x3D; data;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(&quot;end&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">      resolve(JSON.parse(chunk));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">server.on(&quot;request&quot;, async (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  if (req.url &#x3D;&#x3D;&#x3D; &quot;&#x2F;verify&quot;) &#123;</span><br><span class="line">+ const data &#x3D; await resolvePost(req);</span><br><span class="line">+ const &#123; fileHash, filename &#125; &#x3D; data;</span><br><span class="line">+ const ext &#x3D; extractExt(filename);</span><br><span class="line">+ const filePath &#x3D; &#96;$&#123;UPLOAD\_DIR&#125;&#x2F;$&#123;fileHash&#125;$&#123;ext&#125;&#96;;</span><br><span class="line">+ if (fse.existsSync(filePath)) &#123;</span><br><span class="line">+ res.end(</span><br><span class="line">+ JSON.stringify(&#123;</span><br><span class="line">+ shouldUpload: false</span><br><span class="line">+ &#125;)</span><br><span class="line">+ );</span><br><span class="line">+ &#125; else &#123;</span><br><span class="line">+ res.end(</span><br><span class="line">+ JSON.stringify(&#123;</span><br><span class="line">+ shouldUpload: true</span><br><span class="line">+ &#125;)</span><br><span class="line">+ );</span><br><span class="line">+ &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(3000, () &#x3D;&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br></pre></td></tr></table></figure>

<h2 id="暂停上传"><a href="#暂停上传" class="headerlink" title="暂停上传"></a>暂停上传</h2><p>讲完了生成 hash 和文件秒传，回到断点续传。</p>
<p>断点续传顾名思义即断点 + 续传，所以我们第一步先实现”断点”，也就是暂停上传。</p>
<p>原理是使用 <code>XMLHttpRequest</code> 的 <code>abort</code> 方法，可以取消一个 <code>xhr</code> 请求的发送，为此我们需要将上传每个切片的 <code>xhr</code> 对象保存起来，我们再改造一下 <code>request</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   request(&#123;</span><br><span class="line">      url,</span><br><span class="line">      method &#x3D; &quot;post&quot;,</span><br><span class="line">      data,</span><br><span class="line">      headers &#x3D; &#123;&#125;,</span><br><span class="line">      onProgress &#x3D; e &#x3D;&gt; e,</span><br><span class="line">+ requestList</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">      return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">        const xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">        xhr.upload.onprogress &#x3D; onProgress;</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">        Object.keys(headers).forEach(key &#x3D;&gt;</span><br><span class="line">          xhr.setRequestHeader(key, headers[key])</span><br><span class="line">        );</span><br><span class="line">        xhr.send(data);</span><br><span class="line">        xhr.onload &#x3D; e &#x3D;&gt; &#123;</span><br><span class="line">+ &#x2F;&#x2F; 将请求成功的 xhr 从列表中删除</span><br><span class="line">+ if (requestList) &#123;</span><br><span class="line">+ const xhrIndex &#x3D; requestList.findIndex(item &#x3D;\&gt; item &#x3D;&#x3D;&#x3D; xhr);</span><br><span class="line">+ requestList.splice(xhrIndex, 1);</span><br><span class="line">+ &#125;</span><br><span class="line">          resolve(&#123;</span><br><span class="line">            data: e.target.response</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">+ &#x2F;&#x2F; 暴露当前 xhr 给外部</span><br><span class="line">+ requestList?.push(xhr);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>这样在上传切片时传入 <code>requestList</code> 数组作为参数，<code>request</code> 方法就会将所有的 <code>xhr</code> 保存在数组中了。</p>
<p><img src="/Oops/resources/F0B0CFE77677FA589A12DD4019816BBA.jpg" alt></p>
<p>每当一个切片上传成功时，将对应的 <code>xhr</code> 从 <code>requestList</code> 中删除，所以 <code>requestList</code> 中只保存正在上传切片的 <code>xhr</code>。</p>
<p>之后新建一个暂停按钮，当点击按钮时，调用保存在 <code>requestList</code> 中 <code>xhr</code> 的 <code>abort</code> 方法，即取消并清空所有正在上传的切片。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handlePause() &#123;</span><br><span class="line">    this.requestList.forEach(xhr &#x3D;\&gt; xhr?.abort());</span><br><span class="line">    this.requestList &#x3D; [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/Oops/resources/43C78C4882C1D7945AA431C10A98EB2D.png" alt></p>
<p>点击暂停按钮可以看到 <code>xhr</code> 都被取消了。</p>
<p><img src="/Oops/resources/29AF7B0C1C11F3293FD503B89B28B01C.jpg" alt></p>
<h2 id="恢复上传"><a href="#恢复上传" class="headerlink" title="恢复上传"></a>恢复上传</h2><p>之前在介绍断点续传的时提到使用第二种服务端存储的方式实现续传</p>
<p>由于当文件切片上传后，服务端会建立一个文件夹存储所有上传的切片，所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了”<strong>续传</strong>“的效果</p>
<p>而这个接口可以和之前秒传的验证接口合并，前端每次上传前发送一个验证的请求，返回两种结果：</p>
<ol>
<li>服务端已存在该文件，不需要再次上传。</li>
<li>服务端不存在该文件或者已上传部分文件切片，通知前端进行上传，并把<strong>已上传</strong>的文件切片返回给前端。</li>
</ol>
<p>所以我们改造一下之前文件秒传的服务端验证接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">const extractExt &#x3D; filename &#x3D;&gt;</span><br><span class="line">  filename.slice(filename.lastIndexOf(&quot;.&quot;), filename.length); &#x2F;&#x2F; 提取后缀名</span><br><span class="line">const UPLOAD_DIR &#x3D; path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); &#x2F;&#x2F; 大文件存储目录</span><br><span class="line"></span><br><span class="line">const resolvePost &#x3D; req &#x3D;&gt;</span><br><span class="line">  new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    let chunk &#x3D; &quot;&quot;;</span><br><span class="line">    req.on(&quot;data&quot;, data &#x3D;&gt; &#123;</span><br><span class="line">      chunk +&#x3D; data;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(&quot;end&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">      resolve(JSON.parse(chunk));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">+ &#x2F;&#x2F; 返回已经上传切片名列表</span><br><span class="line">+ const createUploadedList &#x3D; async fileHash &#x3D;\&gt;</span><br><span class="line">+ fse.existsSync(&#96;$&#123;UPLOAD\_DIR&#125;&#x2F;$&#123;fileHash&#125;&#96;)</span><br><span class="line">+ ? await fse.readdir(&#96;$&#123;UPLOAD\_DIR&#125;&#x2F;$&#123;fileHash&#125;&#96;)</span><br><span class="line">+ : [];</span><br><span class="line"></span><br><span class="line">server.on(&quot;request&quot;, async (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  if (req.url &#x3D;&#x3D;&#x3D; &quot;&#x2F;verify&quot;) &#123;</span><br><span class="line">    const data &#x3D; await resolvePost(req);</span><br><span class="line">    const &#123; fileHash, filename &#125; &#x3D; data;</span><br><span class="line">    const ext &#x3D; extractExt(filename);</span><br><span class="line">    const filePath &#x3D; &#96;$&#123;UPLOAD_DIR&#125;&#x2F;$&#123;fileHash&#125;$&#123;ext&#125;&#96;;</span><br><span class="line">    if (fse.existsSync(filePath)) &#123;</span><br><span class="line">      res.end(</span><br><span class="line">        JSON.stringify(&#123;</span><br><span class="line">          shouldUpload: false</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.end(</span><br><span class="line">        JSON.stringify(&#123;</span><br><span class="line">          shouldUpload: true，</span><br><span class="line">+ uploadedList: await createUploadedList(fileHash)</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(3000, () &#x3D;&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br></pre></td></tr></table></figure>

<p>接着回到前端，前端有两个地方需要调用验证的接口:</p>
<ol>
<li>点击上传时，检查是否需要上传和已上传的切片。</li>
<li>点击暂停后的恢复上传，返回已上传的切片。</li>
</ol>
<p>新增恢复按钮并改造原来上传切片的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type&#x3D;&quot;file&quot;</span><br><span class="line">        @change&#x3D;&quot;handleFileChange&quot;</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">       &lt;el-button @click&#x3D;&quot;handleUpload&quot;&gt;上传&lt;&#x2F;el-button&gt;</span><br><span class="line">       &lt;el-button @click&#x3D;&quot;handlePause&quot; v-if&#x3D;&quot;isPaused&quot;&gt;暂停&lt;&#x2F;el-button&gt;</span><br><span class="line">+ \&lt;el-button @click&#x3D;&quot;handleResume&quot; v-else\&gt;恢复\&lt;&#x2F;el-button\&gt;</span><br><span class="line">      &#x2F;&#x2F;...</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">+ async handleResume() &#123;</span><br><span class="line">+ const &#123; uploadedList &#125; &#x3D; await this.verifyUpload(</span><br><span class="line">+ this.container.file.name,</span><br><span class="line">+ this.container.hash</span><br><span class="line">+ );</span><br><span class="line">+ await this.uploadChunks(uploadedList);</span><br><span class="line">    &#125;,</span><br><span class="line">    async handleUpload() &#123;</span><br><span class="line">      if (!this.container.file) return;</span><br><span class="line">      const fileChunkList &#x3D; this.createFileChunk(this.container.file);</span><br><span class="line">      this.container.hash &#x3D; await this.calculateHash(fileChunkList);</span><br><span class="line"></span><br><span class="line">+ const &#123; shouldUpload, uploadedList &#125; &#x3D; await this.verifyUpload(</span><br><span class="line">        this.container.file.name,</span><br><span class="line">        this.container.hash</span><br><span class="line">      );</span><br><span class="line">      if (!shouldUpload) &#123;</span><br><span class="line">        this.$message.success(&quot;秒传：上传成功&quot;);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.data &#x3D; fileChunkList.map((&#123; file &#125;, index) &#x3D;&gt; (&#123;</span><br><span class="line">        fileHash: this.container.hash,</span><br><span class="line">        index,</span><br><span class="line">        hash: this.container.hash + &quot;-&quot; + index,</span><br><span class="line">        chunk: file，</span><br><span class="line">        percentage: 0</span><br><span class="line">      &#125;));</span><br><span class="line"></span><br><span class="line">+ await this.uploadChunks(uploadedList);</span><br><span class="line">    &#125;,</span><br><span class="line">   &#x2F;&#x2F; 上传切片，同时过滤已上传的切片</span><br><span class="line">+ async uploadChunks(uploadedList &#x3D; []) &#123;</span><br><span class="line">      const requestList &#x3D; this.data</span><br><span class="line">+ .filter((&#123; hash &#125;) &#x3D;\&gt; !uploadedList.includes(hash))</span><br><span class="line">        .map((&#123; chunk, hash, index &#125;) &#x3D;&gt; &#123;</span><br><span class="line">          const formData &#x3D; new FormData();</span><br><span class="line">          formData.append(&quot;chunk&quot;, chunk);</span><br><span class="line">          formData.append(&quot;hash&quot;, hash);</span><br><span class="line">          formData.append(&quot;filename&quot;, this.container.file.name);</span><br><span class="line">          formData.append(&quot;fileHash&quot;, this.container.hash);</span><br><span class="line">          return &#123; formData, index &#125;;</span><br><span class="line">        &#125;)</span><br><span class="line">        .map(async (&#123; formData, index &#125;) &#x3D;&gt;</span><br><span class="line">          this.request(&#123;</span><br><span class="line">            url: &quot;http:&#x2F;&#x2F;localhost:3000&quot;,</span><br><span class="line">            data: formData,</span><br><span class="line">            onProgress: this.createProgressHandler(this.data[index]),</span><br><span class="line">            requestList: this.requestList</span><br><span class="line">          &#125;)</span><br><span class="line">        );</span><br><span class="line">      await Promise.all(requestList);</span><br><span class="line">      &#x2F;&#x2F; 之前上传的切片数量 + 本次上传的切片数量 &#x3D; 所有切片数量时</span><br><span class="line">      &#x2F;&#x2F; 合并切片</span><br><span class="line">+ if (uploadedList.length + requestList.length &#x3D;&#x3D;&#x3D; this.data.length) &#123;</span><br><span class="line">         await this.mergeRequest();</span><br><span class="line">+ &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/Oops/resources/07B064077E69223CE4D825D503E7E955.jpg" alt></p>
<p>这里给原来上传切片的函数新增 <code>uploadedList</code> 参数，即上图中服务端返回的切片名列表，通过 <code>filter</code> 过滤掉已上传的切片，并且由于新增了已上传的部分，所以之前合并接口的触发条件做了一些改动。</p>
<p>到这里断点续传的功能基本完成了。</p>
<h2 id="进度条改进"><a href="#进度条改进" class="headerlink" title="进度条改进"></a>进度条改进</h2><p>虽然实现了断点续传，但还需要修改一下进度条的显示规则，否则在暂停上传/接收到已上传切片时的进度条会出现偏差。</p>
<h3 id="切片进度条-1"><a href="#切片进度条-1" class="headerlink" title="切片进度条"></a>切片进度条</h3><p>由于在点击上传/恢复上传时，会调用验证接口返回已上传的切片，所以需要将已上传切片的进度变成 100%。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   async handleUpload() &#123;</span><br><span class="line">      if (!this.container.file) return;</span><br><span class="line">      const fileChunkList &#x3D; this.createFileChunk(this.container.file);</span><br><span class="line">      this.container.hash &#x3D; await this.calculateHash(fileChunkList);</span><br><span class="line">      const &#123; shouldUpload, uploadedList &#125; &#x3D; await this.verifyUpload(</span><br><span class="line">        this.container.file.name,</span><br><span class="line">        this.container.hash</span><br><span class="line">      );</span><br><span class="line">      if (!shouldUpload) &#123;</span><br><span class="line">        this.$message.success(&quot;秒传：上传成功&quot;);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      this.data &#x3D; fileChunkList.map((&#123; file &#125;, index) &#x3D;&gt; (&#123;</span><br><span class="line">        fileHash: this.container.hash,</span><br><span class="line">        index,</span><br><span class="line">        hash: this.container.hash + &quot;-&quot; + index,</span><br><span class="line">        chunk: file,</span><br><span class="line">+ percentage: uploadedList.includes(index) ? 100 : 0</span><br><span class="line">      &#125;));</span><br><span class="line">      await this.uploadChunks(uploadedList);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p><code>uploadedList</code> 会返回已上传的切片，在遍历所有切片时判断当前切片是否在已上传列表里即可。</p>
<h3 id="文件进度条-1"><a href="#文件进度条-1" class="headerlink" title="文件进度条"></a>文件进度条</h3><p>之前说到文件进度条是一个计算属性，根据所有切片的上传进度计算而来，这就遇到了一个问题：</p>
<p><img src="/Oops/resources/5485BD43F608BCB1B9EA805D26C96A5E.jpg" alt></p>
<p>点击暂停会取消并清空切片的 <code>xhr</code> 请求，此时如果已经上传了一部分，就会发现文件进度条有<strong>倒退</strong>的现象：</p>
<p><img src="/Oops/resources/CB9B2353F01708D0AE490AD746A90EA0.jpg" alt></p>
<p>当点击恢复时，由于重新创建了 <code>xhr</code> 导致切片进度清零，所以总进度条就会倒退。</p>
<p>解决方案是创建一个”<strong>假</strong>“的进度条，这个假进度条基于文件进度条，但只会停止和增加，然后给用户展示这个假的进度条</p>
<p>这里我们使用 Vue 的监听属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  data: () &#x3D;&gt; (&#123;</span><br><span class="line">+ fakeUploadPercentage: 0</span><br><span class="line">  &#125;),</span><br><span class="line">  computed: &#123;</span><br><span class="line">    uploadPercentage() &#123;</span><br><span class="line">      if (!this.container.file || !this.data.length) return 0;</span><br><span class="line">      const loaded &#x3D; this.data</span><br><span class="line">        .map(item &#x3D;&gt; item.size * item.percentage)</span><br><span class="line">        .reduce((acc, cur) &#x3D;&gt; acc + cur);</span><br><span class="line">      return parseInt((loaded &#x2F; this.container.file.size).toFixed(2));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">+ uploadPercentage(now) &#123;</span><br><span class="line">+ if (now \&gt; this.fakeUploadPercentage) &#123;</span><br><span class="line">+ this.fakeUploadPercentage &#x3D; now;</span><br><span class="line">+ &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>当 <code>uploadPercentage</code> 即真的文件进度条增加时，<code>fakeUploadPercentage</code> 也增加，一旦文件进度条后退，假的进度条只需停止即可。</p>
<p>至此一个<strong>大文件上传</strong> + <strong>断点续传</strong>的解决方案就完成了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大文件上传：</p>
<ul>
<li>前端上传大文件时使用 <code>Blob.prototype.slice</code> 将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片。</li>
<li>服务端接收切片并存储，收到合并请求后使用 <code>fs.appendFileSync</code> 对多个切片进行合并。</li>
<li>原生 <code>XMLHttpRequest</code> 的 <code>upload.onprogress</code> 对切片上传进度的监听。</li>
<li>使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度。</li>
</ul>
<p>断点续传：</p>
<ul>
<li>使用 <code>spart-md5</code> 根据文件内容算出文件 hash。</li>
<li>通过 hash 可以判断服务端是否已经上传该文件，从而直接提示用户上传成功（秒传）。</li>
<li>通过 <code>XMLHttpRequest</code> 的 <code>abort</code> 方法暂停切片的上传。</li>
<li>上传前服务端返回已经上传的切片名，前端跳过这些切片的上传。</li>
</ul>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>源代码增加了一些按钮的状态，交互更加友好，文章表达比较晦涩的地方可以跳转到源代码查看</p>
<p>file-upload[2]</p>
<p><img src="/Oops/resources/85A8E43CC8D823C90FA0F62A16F73974.jpg" alt></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>写给新手前端的各种文件上传攻略，从小图片到大文件断点续传[3]</li>
<li>Blob.slice[4]</li>
</ul>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/oops/uploads/wechat-qcode.jpg" alt="架构组 wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信二维码，订阅我的公众号</div>
</div>

      </div>
    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/oops/2020/04/30/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%20=%20%E6%94%B9%E6%94%B9%E4%BB%A3%E7%A0%81%EF%BC%9F/" rel="next" title="性能优化 = 改改代码？">
                <i class="fa fa-chevron-left"></i> 性能优化 = 改改代码？
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/oops/2020/04/30/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%20SpringBoot+RabbitMQ%20%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF100%20%E6%8A%95%E9%80%92%E6%88%90%E5%8A%9F%E5%B9%B6%E8%A2%AB%E6%B6%88%E8%B4%B9%EF%BC%9F%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89/" rel="prev" title="如何通过 SpringBoot+RabbitMQ 保证消息100 投递成功并被消费？（附源码）">
                如何通过 SpringBoot+RabbitMQ 保证消息100 投递成功并被消费？（附源码） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner" style="text-align:center;">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/oops/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/oops/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/oops/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/oops/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/oops/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/oops/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/oops/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/oops/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/oops/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/oops/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/oops/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
